<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>vue基础 | 豆</title>
<link rel="shortcut icon" href="https://doupo.github.io/favicon.ico?v=1614434275839">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://doupo.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="vue基础 | 豆 - Atom Feed" href="https://doupo.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="@(js学习笔记)
Vue.js
[toc]
结构
	&lt;script&gt;
        //数据
        let data = {
            message:&quot;hello,Vue!&quot;
 ..." />
    <meta name="keywords" content="vue,framework" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://doupo.github.io">
  <img class="avatar" src="https://doupo.github.io/images/avatar.png?v=1614434275839" alt="">
  </a>
  <h1 class="site-title">
    豆
  </h1>
  <p class="site-description">
    For what it is worth ,it is never too late.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              vue基础
            </h2>
            <div class="post-info">
              <span>
                2021-02-23
              </span>
              <span>
                21 min read
              </span>
              
                <a href="https://doupo.github.io/tag/vue/" class="post-tag">
                  # vue
                </a>
              
                <a href="https://doupo.github.io/tag/framework/" class="post-tag">
                  # framework
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>@(js学习笔记)</p>
<h2 id="vuejs">Vue.js</h2>
<p>[toc]</p>
<h4 id="结构">结构</h4>
<pre><code class="language-javascript">	&lt;script&gt;
        //数据
        let data = {
            message:&quot;hello,Vue!&quot;
        }
        //Vm实例
        var vm = new Vue({
            el:&quot;#demo&quot;,  //挂载元素
            data:data
        });
    &lt;/script&gt;
    
    &lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;
        {{ message }}
    &lt;/div&gt;
   
</code></pre>
<hr>
<h3 id="指令和模板">指令和模板</h3>
<h4 id="指令">指令</h4>
<p><a href="http://cn.vuejs.org/v2/api/#v-bind">指令见API</a></p>
<h5 id="列表渲染v-for">列表渲染v-for</h5>
<p><strong>v-for指令</strong></p>
<blockquote>
<p>根据一组数组的选项列表进行渲染<br>
<strong>语法：</strong><br>
value,<code>key in items</code> 注：对象需要是json<br>
value,<code>key of items</code></p>
</blockquote>
<p><strong>变异方法：</strong></p>
<blockquote>
<p>vue提供一组方法，对数组进行操作的时候，会触发视图更新<br>
<code>push(), pop(), shift(), unshift(), splice(), sort(), reverse()</code></p>
</blockquote>
<h5 id="事件处理器v-on">事件处理器v-on</h5>
<blockquote>
<p><strong>v-on指令</strong><br>
用来监听DOM事件触发代码<br>
<strong>语法：</strong><br>
<code>v-on:eventName=“eventHandle”</code><br>
<strong>指令简写：</strong><br>
@<br>
<strong>事件处理函数</strong><br>
写在<code>methods</code>中统一管理<br>
<strong>事件对象</strong><br>
在事件处理函数中获取</p>
</blockquote>
<h5 id="事件修饰符">事件修饰符</h5>
<p>事件处理函数只有纯粹的逻辑判断，不处理DOM事件的细节，<br>
例如：阻止冒泡，取消默认行为，判断按键</p>
<p><strong>修饰符位置：</strong><br>
<code>v-on:eventName.修饰符</code><br>
<strong>修饰符</strong><br>
<code>.stop</code> - 调用 event.stopPropagation()。<br>
<code>.prevent</code> - 调用 event.preventDefault()。<br>
<code>.capture</code> - 添加事件侦听器时使用 capture 模式。<br>
<code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。<br>
<code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。<br>
<code>.native</code> - 监听组件根元素的原生事件。<br>
<code>.once</code> - 只触发一次回调。</p>
<p><strong>按键修饰符</strong><br>
<code>.enter .tab .delete .esc .splace .up .down .left .right .ctrl .alt .shift .meta .键值</code><br>
<code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。<br>
<code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。<br>
<code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</p>
<p><strong>示例：</strong></p>
<ul>
<li>按回车键触发onEnter函数<br>
<code>&lt;input @keyup.13=&quot;onEnter&quot;&gt;</code></li>
</ul>
<blockquote>
<p><a href="http://cn.vuejs.org/v2/api/#v-on">官方文档</a></p>
</blockquote>
<p>注：当函数调用需要传参和调用<code>event</code>对象时候，<br>
<code>@keyup=&quot;handleThis(123, $event)&quot;</code></p>
<h5 id="v-bind-动态绑定class">v-bind---动态绑定class</h5>
<p><a href="http://cn.vuejs.org/v2/api/#v-bind">官方文档</a></p>
<blockquote>
<p>class也为元素的属性，可以使用v-bind:class</p>
</blockquote>
<p><strong>语法：</strong><br>
:class=&quot;{ className:表达式 }&quot;<br>
表达式为true添加className<br>
表达式为false不添加</p>
<p><strong>示例：</strong></p>
<pre><code>&lt;div v-bind:class=&quot;{completed:item.isChecked,editing:edtorTodos === item}&quot;&gt;&lt;/div&gt;

//当item.isChecked的值为true的时候，添加completed样式，可以多个添加，逗号隔开
</code></pre>
<h5 id="条件渲染v-show和v-if"><a href="http://www.cnblogs.com/wmhuang/p/5420344.html">条件渲染v-show和v-if</a></h5>
<p>根据表达式的值来显示/隐藏<br>
<strong>语法：</strong><br>
<code>v-show=&quot;表达式&quot;</code><br>
添加内联的<code>display:none/blcok</code><br>
写在元素标签内</p>
<p>v-if是动态的向DOM树内添加或者删除DOM元素<br>
v-show是通过设置DOM元素的display样式属性控制显隐</p>
<h4 id="自定义指令">自定义指令</h4>
<p><a href="http://cn.vuejs.org/v2/guide/custom-directive.html">官方文档</a></p>
<blockquote>
<p>除了vue内部指令，我们也可以自己设置指令</p>
</blockquote>
<p>在实例化的时候添加directives属性</p>
<h5 id="示例设置输入框焦点">示例设置输入框焦点</h5>
<pre><code class="language-javascript">var vm=new Vue({
	el:'.main',
	data:{
	},
	directives:{
		&quot;focus&quot;:{ //focus值等于v-focus
		//update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。
			update:function(el,binding){
				if(binding.value){
					el.focus();
				}
			}
		}
	}
})

//v-focus=&quot;表达式&quot; 根据表达式的值来判断是否执行 
</code></pre>
<p><a href="http://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">钩子函数</a><br>
<a href="http://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">钩子函数参数</a></p>
<blockquote>
<p><code>el</code>: 指令所绑定的元素，可以用来直接操作 DOM 。<br>
<code>binding</code>: 一个对象，包含以下属性：<br>
<code>name</code>: 指令名，不包括 v- 前缀。<br>
<code>value</code>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, <code>binding.value</code> 的值是 2。</p>
</blockquote>
<hr>
<h4 id="数据处理">数据处理</h4>
<h5 id="计算数据">计算数据</h5>
<p>在计算一个计算属性时候，vue更新它的依赖列表并缓存结果，只有当其中一个依赖发生了变化，缓存的结果才无效<br>
<strong>语法</strong><br>
在选项对象中</p>
<pre><code>computed:{
		//newValue为需要计算的属性，后面函数为计算的方式，最后return结果
		newValue:function(){
			return 计算表达式
		}
	}

var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取，值只须为函数
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // -&gt; 2 //读取a+1=2
vm.aPlus = 3   //调用aPlus.set函数3-1=2
vm.a       // -&gt; 2	//设置之后变成了a=2
vm.aDouble // -&gt; 4	//a*a=2*2=4
</code></pre>
<hr>
<h5 id="数据变动监控">数据变动监控</h5>
<blockquote>
<p>为了发现对象内部值的变化，可以在选项参数中指定<code>deep: true</code>。注意监听数组的变动不需要这么做</p>
</blockquote>
<p><strong>语法</strong><br>
在选项对象中</p>
<pre><code class="language-javascript">watch: {//监控list数据变化
		//无法监控到内部key:value的变化
		 list:function(){
		 	//需要执行的函数
		 }

		//深度监控,包括内部key:value的变化
		list: {
			handler: function () {
				//需要执行的函数
			},
			deep: true
		}
	}
</code></pre>
<hr>
<h4 id="html模板">html模板</h4>
<blockquote>
<p>基于DOM的模板，模板都是可以解析的有效的HTML</p>
</blockquote>
<h5 id="插值">插值</h5>
<h5 id="1文本">1.文本：</h5>
<blockquote>
<p>使用双大括号语法{{ <strong>value</strong> }}</p>
<ul>
<li>作用：替换实例上的属性值，当值内容改变时，插值内容会自动更新</li>
</ul>
</blockquote>
<pre><code class="language-javascript">&lt;script&gt;
        //数据
        let data = {
            message:&quot;hello,Vue!&quot;
        }
        //Vm实例
        var vm = new Vue({
            el:&quot;#demo&quot;,  //挂载元素
            data:data
        });
    &lt;/script&gt;
    
    &lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;
        {{ message }}
    &lt;/div&gt;
</code></pre>
<h5 id="2原生html">2.原生HTML</h5>
<blockquote>
<p>双大括号输出的是文本，不会解析</p>
<ul>
<li>使用<strong>指令</strong> <code>v-html='data'</code>；</li>
</ul>
</blockquote>
<pre><code class="language-javascript">	&lt;script&gt;
        //数据
        let obj = {
            html:&quot;&lt;div&gt;hello,miaov&lt;/div&gt;&quot;,
        }

        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj
        });

    &lt;/script&gt;
    
    &lt;!--模板--&gt;  
    1.文本html
    &lt;div id=&quot;demo&quot;&gt;
        &lt;div&gt;{{ html }}&lt;/div&gt;
    &lt;/div&gt;
	渲染后，div中包含了data中html的内容
	
	2.html结构
	&lt;div id=&quot;demo&quot;&gt;
        &lt;div v-html='html'&gt;&lt;/div&gt;
    &lt;/div&gt;
    渲染后，div中包含了data中html的结构生成一个div
</code></pre>
<h5 id="3属性-自定义属性">3.属性-自定义属性</h5>
<blockquote>
<p>使用<code>v-bind</code>进行绑定，可以相应数据变化<br>
简写方式为<code>:</code></p>
</blockquote>
<pre><code class="language-javascript">	&lt;script&gt;
        //数据
        let obj = {
            abc:1
        }
        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj
        });
    &lt;/script&gt;
    
	&lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot; :custom=&quot;abc&quot;&gt;
    &lt;/div&gt;
</code></pre>
<h5 id="4使用javascript表达式">4.使用JavaScript表达式：</h5>
<blockquote>
<p>写简单的表达式</p>
<ul>
<li><code>{{1+2}}</code> 页面显示3</li>
<li><code>{{ true ? &quot;yes&quot; : &quot;no&quot; }}</code> 页面显示yes</li>
</ul>
</blockquote>
<hr>
<h4 id="template字符串模板">template字符串模板</h4>
<blockquote>
<p>1.模板将会替换挂载的元素，挂载元素的内容都会被替换<br>
2.根节点只能有一个</p>
<ul>
<li>str数据只能有一个根节点，不能有兄弟节点</li>
</ul>
</blockquote>
<pre><code class="language-javascript"> &lt;script&gt;
         //数据
        let obj = {
            html:&quot;&lt;div&gt;hello,123&lt;/div&gt;&quot;,
            abc:&quot;新的属性值&quot;
        };

        var str = '&lt;div :custom=&quot;abc&quot;&gt;hello,{{abc}},&lt;span&gt;你好&lt;/span&gt;&lt;/div&gt;';

        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj,
            template:str
        });
    &lt;/script&gt;
	&lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;
        &lt;span&gt;hi&lt;/span&gt;
    &lt;/div&gt;
</code></pre>
<p>渲染效果：<strong>注意-替换了挂载点</strong><br>
<img src="./1493452129446.png" alt="Alt text" loading="lazy"></p>
<blockquote>
<p>3.将html结构写在一对script中，设置type='x-template'</p>
<ul>
<li>不能跨页面</li>
</ul>
</blockquote>
<pre><code class="language-javascript">&lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;
        &lt;span&gt;hi&lt;/span&gt;
    &lt;/div&gt;
    &lt;script type=&quot;x-template&quot; id=&quot;temp&quot;&gt;
        &lt;div&gt;
            hello,{{abc}},
            &lt;span&gt;你好&lt;/span&gt;
        &lt;/div&gt;
    &lt;/script&gt;
    &lt;script&gt;
        //数据
        let obj = {
            html:&quot;&lt;div&gt;hello,123&lt;/div&gt;&quot;,
            abc:1
        };

        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj,
            template:&quot;#temp&quot;
        });
    &lt;/script&gt;
</code></pre>
<p>渲染效果同上</p>
<hr>
<h4 id="模板-render函数">模板-render函数</h4>
<h5 id="数据对象属性">数据对象属性</h5>
<p>class:{}  //绑定class，和v-bind:class一样的api<br>
<img src="./1493456515574.png" alt="Alt text" loading="lazy"></p>
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ch&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .red{
            color: red;
        }
        .fontsize{
            font-size: 30px;
        }
        .fontw{
            font-weight: bold;
        }
    &lt;/style&gt;
    &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;
        &lt;span class=&quot;fontsize&quot; :class='{red:addClass,fontw:font}'&gt;hello&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //数据
        let obj = {
            addClass:true,
            font:true
        };

        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj
        });

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>style:{}  //绑定样式，和v-bind:style一样的api<br>
attrs:{}  //添加行间属性<br>
domProps:{}  //DOM元素属性<br>
on:{}  //绑定事件<br>
<strong>综合实例</strong></p>
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ch&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .bg {
            background: yellow;
        }
    &lt;/style&gt;
    &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;!--模板--&gt;
    &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        //数据
        let obj = {
            title:&quot;数据内容&quot;
        };

        var vm = new Vue({
            el:&quot;#demo&quot;,
            data:obj,
            render(createElement){
                return createElement(
                    &quot;ul&quot;,
                    {
                        class: {
                            bg:true
                            //设置class
                        },
                        style:{
                            fontSize:&quot;50px&quot;,
                            fontWeight:&quot;bold&quot;
                            //添加内联样式
                        },
                        attrs:{
                            abc:&quot;title&quot;
                            //设置自定义属性
                            //也可以引用data数据
                            //abc:obj.title
                        },
                        domProps:{
                            innerHTML:&quot;&lt;li&gt;我的内容会替换掉下面生成的li&lt;/li&gt;&quot;,
                            onclick:function(){
                                alert('2');
                            }
                            //DOM元素属性
                        },
                        on:{
                            click:function () {
                                alert('1');
                            }
                            //绑定click事件
                        }
                    },
                    [
                        createElement(&quot;li&quot;,1)
                        //生成一个内容为1的li元素
                    ]
                );
            }
        });

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="./1493458070780.png" alt="Alt text" loading="lazy"></figure>
<blockquote>
<p>组件应用</p>
</blockquote>
<p>nativeOn:{}  //监听原生事件<br>
directives:{}  //自定义指令<br>
scopedSlots:{}  //slot作用域<br>
slot:{}  //定义slot名称<br>
key:&quot;key&quot;  //给元素添加唯一标识<br>
ref:&quot;ref&quot;    //引用信息</p>
<hr>
<h2 id="组件">组件</h2>
<h5 id="组件开发的优势">组件开发的优势</h5>
<blockquote>
<p>提高开发效率<br>
方便重复使用<br>
简单调试步骤<br>
方便项目维护<br>
便于协同开发</p>
</blockquote>
<h5 id="组件构成">组件构成</h5>
<blockquote>
<p>样式结构<br>
行为逻辑<br>
数据</p>
</blockquote>
<h3 id="组件注册">组件注册</h3>
<h5 id="全局注册">全局注册</h5>
<p><strong>语法：</strong><br>
<code>Vue.component('newTag', {})</code></p>
<pre><code class="language-javascript">//全局组件
Vue.component('newTag', {
	//data数据，需要为函数,返回数据，模板不能使用共同的数据
	data:function(){
	    return {
		    key:value,
		    key:value
	    }
	}，
	props: ['count'],
	template: `
	  &lt;div&gt;
		&lt;h2&gt;我是一个自定义的组件&lt;/h2&gt;
			&lt;input type=&quot;button&quot;
			v-bind:value=&quot;count&quot;
			//接受参数，渲染为value=“需要传递的参数——实参”
			@click=&quot;changeCount&quot;
			/&gt;
	{{ incrementCount2 }}
 	&lt;/div&gt;
			`
});

//props调用组件的时候传递参数
//html代码
&lt;newTag count='需要传递的参数——实参'&gt;&lt;/newTag&gt;
</code></pre>
<h5 id="局部注册">局部注册</h5>
<p>语法：<code>new Vue({component:{}})</code></p>
<pre><code class="language-javascript">		new Vue({
				el:&quot;#app&quot;,
				component:{
					'custom-component':{
						template:`
						&lt;div&gt;
						&lt;h2&gt;我是一个自定义的组件&lt;/h2&gt;
						&lt;input type=&quot;button&quot; value=&quot;改变count的值&quot; @click=&quot;changeCount&quot; /&gt;
						{{incrementCount2}}
					&lt;/div&gt;`
					}
				}
			})
</code></pre>
<h5 id="特殊is属性扩展原生html元素">特殊is属性扩展原生html元素</h5>
<blockquote>
<p>比如table中放自定义的组件，浏览器解析会报错</p>
</blockquote>
<p>**解决方法：**不推荐使用 <strong>不符合W3C标准的DOM结构</strong></p>
<pre><code>	&lt;table&gt;
        &lt;tr is=&quot;自定义组件name&quot;&gt;&lt;/tr&gt;
    &lt;/table&gt;
    
	//解析：
	&lt;table&gt;
        自定义组件name的整个结构
    &lt;/table&gt;
</code></pre>
<h4 id="组件之间的通信">组件之间的通信</h4>
<figure data-type="image" tabindex="2"><img src="./1493783216718.png" alt="Alt text" loading="lazy"></figure>
<h5 id="父组件子组件">父组件==&gt;子组件</h5>
<p>组件实例是孤立的，不能再子组件直接使用父组件的数据。<br>
可以在子组件上使用自定义属性绑定<code>v-bind</code>数据，在组件中需要显式的用<br>
<code>props</code>声明自定义属性名</p>
<p>**注：**使用<code>v-bind</code>绑定的是动态数据，<br>
如果只是传递一个静态数据（字符串），可以直接写自定义属性<br>
<code>but=&quot;count&quot;</code></p>
<h5 id="自定义属性的命名规则">自定义属性的命名规则</h5>
<blockquote>
<p>驼峰(ameCase)，烤串(name-case)</p>
</blockquote>
<p><strong>注</strong><br>
无论是驼峰，大驼峰，烤串，还是单个，<br>
在<code>props</code>的时候必须合并</p>
<blockquote>
<p>name-case ==&gt; ameCase<br>
namecase ==&gt; namecase</p>
</blockquote>
<blockquote>
<p>自定义属性用小写，避免出现转换出错</p>
</blockquote>
<h5 id="子组件父组件">子组件==&gt;父组件</h5>
<p>需要使用自定义事件，父组件用<code>v-on</code>监听自定义事件，<code>$emit</code>触发父组件所关心的自定义事件</p>
<blockquote>
<p>1.子组件向父组件传值</p>
<ul>
<li>要执行的函数==&gt;需要做什么==&gt;<code>this.$emit(&quot;自定义事件名称&quot;)</code></li>
</ul>
<p>2.父级，需要<code>@自定义事件名称=&quot;要执行的函数&quot;</code></p>
<ul>
<li>父级监控到事件执行后，如果有需要，就执行后面函数，不需要可不写</li>
</ul>
</blockquote>
<h5 id="综合示例">综合示例：</h5>
<pre><code>	&lt;body&gt;
		&lt;div id=&quot;app&quot;&gt;
			&lt;h3&gt;父组件中使用了count同时把它传递给子组件&lt;/h3&gt;
			&lt;!-- 父组件中使用了count同时把它传递给子组件 --&gt;
			&lt;p&gt;{{count}}&lt;/p&gt;
			&lt;!-- 父组件调用count --&gt;

			&lt;custom-component :count1=&quot;count&quot; but=&quot;改变count的值&quot; @increment-click=&quot;countHandle&quot;&gt;&lt;/custom-component&gt;
			&lt;!-- but=&quot;改变count的值&quot;非动态数据传递 --&gt;
			&lt;!-- 子组件用count1接受了父组件传过来的count ==&gt; A1 --&gt;
			&lt;!-- B2==&gt; @increment-click=&quot;countHandle&quot; 当子组件触发函数后告知了父组件，父组件接受到信号后，执行countHandle函数 ==&gt;B3 --&gt;
		&lt;/div&gt;
		&lt;script&gt;

		//自定义事件 
			//全局组件
			Vue.component('custom-component',{
				props:['count1','but'],
				//A1==&gt; 用props声明自定义属性名  ==&gt;A2
				data:function () {
					return {
						val:''
					}
				},
				template:`
					&lt;div&gt;
						&lt;h2&gt;我是一个自定义的组件&lt;/h2&gt;
						&lt;input type=&quot;button&quot; :value=&quot;but&quot;  @click=&quot;changeCount(count1)&quot; /&gt;
						{{val}}
					&lt;/div&gt;
				`,
				//:value=&quot;but&quot; 非动态数据传递
				//A2 ==&gt; @click=&quot;changeCount(count1)&quot; 点击执行组件内部的函数 将count1作为参数传入 ==&gt; B1

				methods:{
					changeCount(count1){
						this.val=count1+1;
						// alert(&quot;子组件点击了&quot;);
						this.$emit(&quot;increment-click&quot;,this.val)	

						//B1==&gt; 当子组件点击的时候，触发了组件内部val值得递增，同时将值传递出去 ==&gt; B2
					}
				}
			})

			new Vue({
				el:&quot;#app&quot;,
				data:{
					count:12
				},
				methods:{
					countHandle(value1){
						this.count=value1;
						//==&gt;B3 将传递过来的数据赋值给count，数据发生了改变，又同步给了子组件
					}
				}
			})
		&lt;/script&gt;
	&lt;/body&gt;
</code></pre>
<h5 id="单向数据流">单向数据流</h5>
<p>数据从父组件传递给子组件，只能单向绑定。子组件内部不能修改传递过来的数据。</p>
<p><strong>更改数据</strong><br>
作为局部这个组件的data的初始值和用computed来处理数据<br>
这两种方式，改变的都是处理后的数据，和传递的数据无关<br>
<strong>推荐使用方法1</strong></p>
<pre><code>&lt;body&gt;
		&lt;div id=&quot;app&quot;&gt;
			&lt;h3&gt;父组件中使用了count&lt;/h3&gt;
			&lt;p&gt;{{count}}&lt;/p&gt;
			&lt;custom-component :count=&quot;count&quot;&gt;&lt;/custom-component&gt;
		&lt;/div&gt;
		&lt;script&gt;

		//自定义事件 

			//全局组件
			Vue.component('custom-component',{
				props:['count'],
				data(){
					return {
						incrementCount:this.count  //作为局部这个组件的data的初始值
						//方法1可以用来直接使用返回的key值
					}
				},
				/* computed:{
				 	incrementCount2(){
				 		return this.incrementCount
				 	}
				 },
				*/

				//方法2，利用computed处理数据（需要方法1配合），使用它的返回值incrementCount2


				template:`
					&lt;div&gt;
						&lt;h2&gt;我是一个自定义的组件&lt;/h2&gt;
						&lt;input type=&quot;button&quot; value=&quot;改变count的值&quot; @click=&quot;changeCount&quot; /&gt;
						{{incrementCount}}
						{{count}}
					&lt;/div&gt;
				`,
				methods:{
					changeCount(){
						this.incrementCount++;	
					}
				}
			})

			new Vue({
				el:&quot;#app&quot;,
				data:{
					count:0
				}
			})
		&lt;/script&gt;
</code></pre>
<h4 id="props验证">props验证</h4>
<h5 id="1指定类型验证type">1指定类型验证type</h5>
<blockquote>
<p>如果传入数据类型不是Number，控制台会提示，但是不影响页面渲染</p>
</blockquote>
<pre><code class="language-javascript">props: {
	count: {
		type: Number,  //单个验证
		type:[Number,String],  //多个验证，可以为数字和字符串
			}
}
</code></pre>
<h5 id="2设置默认数据default">2设置默认数据default</h5>
<blockquote>
<p>默认数据仅在父组件没有传递数据过来的情况下生效</p>
</blockquote>
<pre><code class="language-javascript">props: {
	count: {
		default:10
	}
}
</code></pre>
<h5 id="3参数是否必须传递">3参数是否必须传递</h5>
<blockquote>
<p>required:true为true为必须传递，否则控制台会提示</p>
</blockquote>
<pre><code class="language-javascript">props: {
	count: {
		required:true
	}
}
</code></pre>
<h5 id="自定义验证规则">自定义验证规则</h5>
<pre><code class="language-javascript">validator:function (value){
	return value &gt; 10  //验证是否大于10，否控制台提示
}
</code></pre>
<hr>
<h4 id="使用slot渲染内容">使用slot渲染内容</h4>
<p><a href="http://cn.vuejs.org/v2/guide/components.html#%E4%BD%BF%E7%94%A8-Slot-%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9">官方API</a></p>
<blockquote>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 <slot> 元素作为原始内容的插槽。</p>
</blockquote>
<h5 id="单个slot">单个slot</h5>
<p>在子组件模板中有slot标签，被视为备用内容，在父组件不提供内容的情况下使用。如果父组件提供内容，则整个内容替换slot</p>
<h5 id="具名slot">具名slot</h5>
<p>slot元素可以用一个特殊的属性name来配置对应的内容。</p>
<h5 id="编译作用域">编译作用域</h5>
<p><strong>注</strong>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p>
<h5 id="综合例子">综合例子</h5>
<pre><code>		&lt;div id=&quot;app&quot;&gt;
			&lt;h2&gt;自定义组件&lt;/h2&gt;
			&lt;custom&gt;
				&lt;!-- 当写在自定义标签之间的内容 要混合子组件中的模板 --&gt;
				&lt;div  style=&quot;color: green&quot; slot=&quot;one&quot;&gt;替换第1给提醒&lt;/div&gt;
				&lt;div slot=&quot;three&quot;&gt;替换第3给提醒&lt;/div&gt;
				&lt;template slot=&quot;two&quot; &gt;
					&lt;div style=&quot;color:blue;font-size: 20px&quot;&gt;{{message}}&lt;/div&gt;  &lt;!-- 编译后数据来自父组件 --&gt;
					&lt;div style=&quot;color: blue&quot;&gt;替换第2给提醒&lt;/div&gt;
				&lt;/template&gt;

				&lt;div style=&quot;color: red&quot;&gt;替换无名的slot&lt;/div&gt;   &lt;!-- 替换匿名的slot，如果没有，则不显示 --&gt;
				&lt;div style=&quot;color: red&quot;&gt;替换无名的slot2&lt;/div&gt;

			&lt;/custom&gt;
		&lt;/div&gt;

		&lt;script&gt;
			//定制模板 div
			Vue.component(&quot;custom&quot;,{
				data(){
					return {
						message:'我是子组件的数据'
					}
				},
				template:`
					&lt;div&gt;
						&lt;slot name=&quot;one&quot;&gt;&lt;p&gt;这是第1个提醒&lt;/p&gt;&lt;/slot&gt;
						&lt;slot name=&quot;two&quot;&gt;&lt;p&gt;这是第2个提醒&lt;/p&gt;&lt;/slot&gt;
						&lt;slot name=&quot;three&quot;&gt;&lt;p&gt;这是第3个提醒&lt;/p&gt;&lt;/slot&gt;

						&lt;slot&gt;无名的slot&lt;/slot&gt;	

						&lt;p style=&quot;color:blue;font-size: 30px&quot;&gt;{{message}}&lt;/p&gt;  &lt;!--数据来自子组件--&gt;
					&lt;/div&gt;
				`
			})

			new Vue({
				el:&quot;#app&quot;,
				data:{
					message:'我是来自父组件的数据'
				}
			});
		&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="./1494058226354.png" alt="Alt text" loading="lazy"></figure>
<hr>
<h4 id="动态组件">动态组件</h4>
<blockquote>
<p>多个组件可以使用同一个挂载点，动态的切换渲染的组件<br>
使用<code>&lt;component&gt;</code>元素，使用<code>is</code>特性进行动态绑定<br>
<code>&lt;keep-alive&gt;</code>可以将渲染过的组件状态等保留在内存中，避免下次切换重新渲染</p>
</blockquote>
<p><strong>示例：</strong></p>
<pre><code>        &lt;div id=&quot;app&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;切换到第1个组件&quot; @click=&quot;tabComponent(1)&quot; /&gt;
            &lt;input type=&quot;button&quot; value=&quot;切换到第2个组件&quot; @click=&quot;tabComponent(2)&quot;/&gt;
            &lt;input type=&quot;button&quot; value=&quot;切换到第3个组件&quot; @click=&quot;tabComponent(3)&quot;/&gt;
            &lt;keep-alive&gt;  
                &lt;component :is=&quot;current&quot;&gt;&lt;/component&gt;
            &lt;/keep-alive&gt;
            
        &lt;/div&gt;

        &lt;script&gt;
            /*动态组件*/
            var custom1 = Vue.component(&quot;custom1&quot;,{
                template:`&lt;div @click=&quot;changeDivbg&quot;&gt;我是第1个组件&lt;/div&gt;`,
                methods:{
                    changeDivbg(ev){
                        ev.target.style.background = &quot;red&quot;;
                    }
                }
            });
            var custom2 = Vue.component(&quot;custom2&quot;,{
                template:`&lt;div&gt;我是第2个组件&lt;/div&gt;`
            })
             var custom3  = Vue.component(&quot;custom3&quot;,{
                template:`&lt;div&gt;我是第3个组件&lt;/div&gt;`
            })

            new Vue({
                el:&quot;#app&quot;,
                data:{
                    current:custom1
                },
                methods:{
                    tabComponent(index){
                        if(index === 1){
                            this.current = custom1
                        }else if(index === 2){
                            this.current = custom2
                        }else if(index === 3){
                            this.current = custom3
                        }
                    }
                }
            })
        &lt;/script&gt;
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#vuejs">Vue.js</a><br>
*
<ul>
<li><a href="#%E7%BB%93%E6%9E%84">结构</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%A8%A1%E6%9D%BF">指令和模板</a>
<ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a>
<ul>
<li><a href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for">列表渲染v-for</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8v-on">事件处理器v-on</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符</a></li>
<li><a href="#v-bind-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass">v-bind---动态绑定class</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93v-show%E5%92%8Cv-if">条件渲染v-show和v-if</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">自定义指令</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%85%A5%E6%A1%86%E7%84%A6%E7%82%B9">示例设置输入框焦点</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</a>
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE">计算数据</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8A%A8%E7%9B%91%E6%8E%A7">数据变动监控</a></li>
</ul>
</li>
<li><a href="#html%E6%A8%A1%E6%9D%BF">html模板</a>
<ul>
<li><a href="#%E6%8F%92%E5%80%BC">插值</a></li>
<li><a href="#1%E6%96%87%E6%9C%AC">1.文本：</a></li>
<li><a href="#2%E5%8E%9F%E7%94%9Fhtml">2.原生HTML</a></li>
<li><a href="#3%E5%B1%9E%E6%80%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7">3.属性-自定义属性</a></li>
<li><a href="#4%E4%BD%BF%E7%94%A8javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.使用JavaScript表达式：</a></li>
</ul>
</li>
<li><a href="#template%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF">template字符串模板</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF-render%E5%87%BD%E6%95%B0">模板-render函数</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">数据对象属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%84%E4%BB%B6">组件</a><br>
*<br>
*<br>
* <a href="#%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF">组件开发的优势</a><br>
* <a href="#%E7%BB%84%E4%BB%B6%E6%9E%84%E6%88%90">组件构成</a>
<ul>
<li><a href="#%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C">组件注册</a><br>
*
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C">全局注册</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C">局部注册</a></li>
<li><a href="#%E7%89%B9%E6%AE%8Ais%E5%B1%9E%E6%80%A7%E6%89%A9%E5%B1%95%E5%8E%9F%E7%94%9Fhtml%E5%85%83%E7%B4%A0">特殊is属性扩展原生html元素</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">组件之间的通信</a>
<ul>
<li><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AD%90%E7%BB%84%E4%BB%B6">父组件==&gt;子组件</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">自定义属性的命名规则</a></li>
<li><a href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E7%88%B6%E7%BB%84%E4%BB%B6">子组件==&gt;父组件</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B">综合示例：</a></li>
<li><a href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">单向数据流</a></li>
</ul>
</li>
<li><a href="#props%E9%AA%8C%E8%AF%81">props验证</a>
<ul>
<li><a href="#1%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%AA%8C%E8%AF%81type">1指定类型验证type</a></li>
<li><a href="#2%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AEdefault">2设置默认数据default</a></li>
<li><a href="#3%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB%E4%BC%A0%E9%80%92">3参数是否必须传递</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99">自定义验证规则</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8slot%E6%B8%B2%E6%9F%93%E5%86%85%E5%AE%B9">使用slot渲染内容</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%AAslot">单个slot</a></li>
<li><a href="#%E5%85%B7%E5%90%8Dslot">具名slot</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8%E5%9F%9F">编译作用域</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E4%BE%8B%E5%AD%90">综合例子</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://doupo.github.io/post/mongoose/">
              <h3 class="post-title">
                MongoDB
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by 土豆
  <a class="rss" href="https://doupo.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
